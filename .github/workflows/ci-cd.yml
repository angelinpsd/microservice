  name: DevOps Microservice CI/CD - 5 Stages

  on:
    push:
      branches: [ master ]
    workflow_dispatch:

  env:
    AWS_REGION: us-east-1
    ECR_REPOSITORY: devops-microservice
    EKS_CLUSTER_NAME: devops-microservice-cluster
    K8S_NAMESPACE: prod-micros

  jobs:
    # STAGE 1: INFRAESTRUCTURA CON TERRAFORM
    infrastructure:
      name: "1. Infrastructure as Code"
      runs-on: ubuntu-latest
      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Setup Terraform
          uses: hashicorp/setup-terraform@v3

        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v4
          with:
            aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-region: ${{ env.AWS_REGION }}

        - name: Terraform Init
          run: |
            cd infrastructure/terraform
            terraform init

        - name: Terraform Validate
          run: |
            cd infrastructure/terraform
            terraform validate

        - name: Terraform Plan
          run: |
            cd infrastructure/terraform
            terraform plan

        - name: Terraform Apply
          if: github.ref == 'refs/heads/master'
          run: |
            cd infrastructure/terraform
            terraform apply -auto-approve
    # STAGE 2: BUILD
    build:
      name: "2. Build Application"
      runs-on: ubuntu-latest
      needs: infrastructure
      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Set up JDK 17
          uses: actions/setup-java@v4
          with:
            java-version: '17'
            distribution: 'temurin'
            cache: 'maven'

        - name: Build with Maven
          run: mvn clean compile -DskipTests

    # STAGE 3: TEST
    # STAGE 3: TEST
    test:
      name: "3. Run Tests"
      runs-on: ubuntu-latest
      needs: build
      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Set up JDK 17
          uses: actions/setup-java@v4
          with:
            java-version: '17'
            distribution: 'temurin'
            cache: 'maven'

        - name: Run tests
          run: mvn test

        - name: Build package
          run: mvn package -DskipTests

        - name: Upload JAR artifact
          uses: actions/upload-artifact@v4
          with:
            name: microservice-jar
            path: target/*.jar
            retention-days: 3
    # STAGE 4: CONTAINER IMAGE
    # STAGE 4: CONTAINER IMAGE
    container-image:
      name: "4. Build & Push Container"
      runs-on: ubuntu-latest
      needs: test
      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Download JAR artifact
          uses: actions/download-artifact@v4
          with:
            name: microservice-jar
            path: target/

        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v4
          with:
            aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-region: ${{ env.AWS_REGION }}

        - name: Login to Amazon ECR
          id: login-ecr
          uses: aws-actions/amazon-ecr-login@v2

        - name: Build Docker image
          run: |
            docker build -t $ECR_REPOSITORY:latest .
            docker tag $ECR_REPOSITORY:latest ${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:latest

        - name: Push Docker image to ECR
          run: |
            docker push ${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:latest

    # STAGE 5: DEPLOY TO KUBERNETES
    deploy:
      name: "5. Deploy to Kubernetes"
      runs-on: ubuntu-latest
      needs: [ infrastructure, container-image ]
      if: github.ref == 'refs/heads/master'
      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v4
          with:
            aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-region: ${{ env.AWS_REGION }}

        - name: login to EKS
          run: |
            aws eks update-kubeconfig \
              --region $AWS_REGION \
              --name $EKS_CLUSTER_NAME

        - name: Setup ECR Access for EKS
          run: |
            # Get EKS node role
            NODE_ROLE=$(aws eks describe-nodegroup --cluster-name $EKS_CLUSTER_NAME --nodegroup-name devops-nodes --query 'nodegroup.nodeRole' --output text)
            echo "EKS Node Role: $NODE_ROLE"
            
            # Verify ECR access
            aws ecr describe-repositories --repository-names $ECR_REPOSITORY
            echo "ECR repositorio es accessible"

        - name: Deploy to EKS
          run: |
            # Get ECR repository URL
            ECR_URL="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest"
            
            # Update deployment with actual ECR URL
            sed -i "s|ECR_REPOSITORY_URL_PLACEHOLDER|$ECR_URL|g" infrastructure/kubernetes/deployment.yml
            grep "image:" infrastructure/kubernetes/deployment.yml
            echo "Deploying with image: $ECR_URL"
            
            # Create namespace if not exists
            kubectl create namespace $K8S_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
            
            # Apply Kubernetes manifests
            kubectl apply -f infrastructure/kubernetes/deployment.yml -n $K8S_NAMESPACE
            kubectl apply -f infrastructure/kubernetes/service.yml -n $K8S_NAMESPACE
            
            # Wait for deployment to complete with better debugging
            echo "Waiting for deployment rollout..."
            kubectl rollout status deployment/devops-microservice -n $K8S_NAMESPACE --timeout=600s
            
            # Debug: Show pod status if rollout fails
            kubectl get pods -n $K8S_NAMESPACE -o wide
            kubectl describe deployment/devops-microservice -n $K8S_NAMESPACE

        - name: Get Load Balancer URL
          run: |
            echo "Load Balancer URL:"
            LB=kubectl get service devops-microservice-service -n $K8S_NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
            echo "$LB"
            echo "Microservice response:"
            curl -X POST \
            -H "X-Parse-REST-API-Key: 2f5ae96c-b558-4c7b-a590-a501ae1c3f6c" \
            -H "X-JWT-KWY: ${JWT}" \
            -H "Content-Type: application/json" \
            -d '{ "message": "This is a test", "to": "Juan Perez", "from": "Rita Asturia", "timeToLifeSec": 45 }' \
            http://$LB/DevOps

            
